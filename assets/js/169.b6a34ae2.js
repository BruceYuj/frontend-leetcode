(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{536:function(t,v,_){"use strict";_.r(v);var n=_(27),s=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),_("p",[t._v("递归是计算机科学中的一个重要概念。它是许多其他算法和数据结构的基础。")]),t._v(" "),_("p",[t._v("本篇主要回答以下几个问题：")]),t._v(" "),_("ol",[_("li",[t._v("递归是什么？")]),t._v(" "),_("li",[t._v("递归能够解决什么问题？")]),t._v(" "),_("li",[t._v("递归和动态规划、分治、贪心之间的关系")])]),t._v(" "),_("h2",{attrs:{id:"递归详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#递归详解"}},[t._v("#")]),t._v(" 递归详解")]),t._v(" "),_("p",[t._v("递归的基本思想是某个函数直接或间接地调用自身，这样就把原问题的求解转换成许多相同性质但是规模更小的子问题。"),_("strong",[t._v("我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。")])]),t._v(" "),_("p",[_("strong",[t._v("和枚举最大的区别在于，枚举是横向地把问题划分，然后依次解决子问题，而递归则是把问题逐级分解，是纵向的拆分。")])]),t._v(" "),_("p",[t._v("举个简单的例子：")]),t._v(" "),_("ol",[_("li",[t._v("如何给一堆数字排序？\n"),_("ul",[_("li",[t._v("分成两半，先排左半边，再排右半边，最后合并就好了。至于如何排左半边和右半边，请重新阅读这句话。")])])]),t._v(" "),_("li",[t._v("你今年多少岁\n"),_("ul",[_("li",[t._v("去年的岁数加一")])])])]),t._v(" "),_("p",[t._v("递归代码的最重要的两个特征： 结束条件和自我调用。")]),t._v(" "),_("ul",[_("li",[t._v("自我调用是在解决子问题")]),t._v(" "),_("li",[t._v("结束条件则是定义了最简单的子问题")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("function f(传入数值) {\n  if(终止条件) return 最小子问题解;\n  return f(缩小规模);\n}\n")])])]),_("p",[t._v("那么写递归的技巧是什么？\n"),_("strong",[t._v("明白一个函数的作用并相信它能够完成这个任务，千万不要试图跳进细节")])]),t._v(" "),_("p",[t._v("递归和动态规划。分治的关系：\n分治和动态规划很大程度上是递归思想基础上的，解决更具体问题的两类算法思想（虽然实现动态规划时大部分都不是递归写法，而是递推写法了，但是过程和思想是一致的）。贪心算法是动态规划算法的一个子集，可以更高效地解决一部分更特殊的问题。")]),t._v(" "),_("p",[t._v("以最经典的归并排序为例，它把待排序数组不断二分为规模更小的子问题处理，这就是“分而治之”这个词的由来。显然，排序问题分解出的子问题是不重复的，如果有的问题分解后的子问题有重复的（重叠子问题性质），那么这就交给动态规划算法去解决。")])])}),[],!1,null,null,null);v.default=s.exports}}]);